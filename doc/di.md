# mini tutorial по инжектам

вопрос: есть какой то глобальный сервис, его нужно где-то получить. какие варианты действий?

## статика
```ts
class Service {
	static readonly instance = new Service()
}

// ...

Service.instance.use()
```

плюсы:
- легко
минусы:
- ужасная тестируемость
- проблемы с инициализацией

## передача в аргументы
```ts
class Service {}

// ...

class User {
	constructor(service: IService) {
		service.use()
	}
}
```
плюсы:
- тестируемость (можно передать чё угодно вместо настоящего Service)
минусы:
- пиздец неудобно, это каждый аргумент передавать везде по всей цепочке (я пробовал, не советую)

## передача в аргументы одного объекта
```ts
class Service {}

// ...

class User {
	constructor(services: ServiceList) {
		(services.get('Service') as Service).use()
	}
}
```
плюсы:
- те же что в прошлом
- намного удобнее чем слать каждый объект отдельно
минусы:
- всё еще пиздец неудобно, передавать всё еще надо по всей цепочке (хоть и тока один объект), + надо либо хранить весь список сервисов в типе
```ts
interface Services {
	readonly service: Service;
	// ...
}
```
а это пиздец, либо доставать по каким то ключам которые невозможно будет типизировать


## ну так вот
если есть какие другие способы был бы рад послушать, иначе пашол нахуй
моя либа DI по сути просто вяляется третьим вариантом но с упрощённым использованием
(класс `DIContainer` просто хранит в себе Map<string, () => unknown>)

базовое использование:
```ts
// регистрация инстанса в контейнере
di.registerSingleton(new Service());

// ...

// получение того же инстанса
di.resolve<Service>();
```
базово, это всё что происходит. ну, внутри оно там хуйню творит чтобы генерировать уникальные строковые ключи для всего этого но похуй неважно
но такие базы они неинтересны, можно сделать ещё проще
и вот тут собственно inject

вот написал ты
```ts
@injectable
class Service2 {
	constructor(id: string, @inject service: Service1) { }
}
```
оно компилируется в
```ts
class Service2 {
	static depsCreate(id: string, di: DIContainer) {
		return new Service2(id, di.resolve<Service1>());
	}
	constructor(id: string, service: Service1) { }
}
```
и потом, если зарегистрировать его как
```ts
di.registerTransientClass(Service2);
```
то при любом .resolve будет создаваться новый инстанс класса, и все инжект параметры будут автоматически резолвлены (тоесть вызван метод `depsCreate`)

ну или
```ts
di.registerSingletonClass(Service2);
```
чтобы создался максимум один и возвращался тока он

назревает другой вопрос а нахуя классы регистрировать вообще? ну вообще не надо, можно вызвать
```ts
di.resolveForeignClass(Service2);
```
и получишь нужный инстанс; но,
1. каждый раз новый, тоесть синглтоны так не сделаешь
2. резолвинг принимает *тип* а регистрация (или resolveForeignClass) принимает *класс*, что значит что для регистрации нужен *импорт класса* что намного увеличивает шанс циркулярных зависимостей импорта и может создать проблемы с порядком инициализации

так что любые сервисы регистрируются в SandboxGame.cs (по файлу на клиент и сервер) и потом получаешь где хочешь
но если надо чёто локальное, которое никому еще не надо и вообще лень, то можно и resolveForeignClass. я его например в TutorialController использую для создания нового туториал плота


дополнительно, сам DIContainer зарегистрирован в себе же, так что можно сделать @inject di: DIContainer и делать че угодно

еще дополнительней, тип DIContainer позволяет только резолвить, не регистрировать
для регистрации надо создать дочерний scope
```ts
const scoped = di.beginScope((di) => {
	di.registerSingleton(tool);
});
```
`scoped` будет иметь все регистрации из `di` но также новые свои; но новые обратно в `di` не попадут


## хостинг
для запуска игры используется GameHost
сначала создаётся GameHostBuilder в который регистрируется всякая хуйня
+ дополнительно можно регистрировать именно *сервисы* - что то, что запустится сразу после сборки хоста
```ts
builder.services.registerService(GraphicsSettingsController);
```
после сборки (в *.main.ts) получается GameHost с DIContainer внутри со всеми нарегистрированными штуками и запущенными *сервисами*
